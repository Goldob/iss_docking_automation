#!/usr/bin/env python

import rospy
import tf2_ros
import tf_conversions

from std_srvs.srv import Empty
from std_msgs.msg import Float64

import numpy as np
from iss_docking_automation import StateBuffer

# Source: https://answers.ros.org/question/196149/how-to-rotate-vector-by-quaternion-in-python/?answer=196155#post-id-196155
def qv_mult(q1, v1):
    mag = np.linalg.norm(v1)

    v1 = tf_conversions.transformations.unit_vector(v1)
    q2 = list(v1)
    q2.append(0.0)
    return tf_conversions.transformations.quaternion_multiply(
        tf_conversions.transformations.quaternion_multiply(q1, q2),
        tf_conversions.transformations.quaternion_conjugate(q1)
    )[:3] * mag

if __name__ == '__main__':
    rospy.init_node('corrections_applicator')
    corrections_buffer = StateBuffer()

    # Translation corrections
    rospy.Subscriber('corrections/x', Float64, corrections_buffer.handle_x)
    rospy.Subscriber('corrections/y', Float64, corrections_buffer.handle_y)
    rospy.Subscriber('corrections/z', Float64, corrections_buffer.handle_z)

    # Rotation corrections
    rospy.Subscriber('corrections/yaw'  , Float64, corrections_buffer.handle_yaw)
    rospy.Subscriber('corrections/pitch', Float64, corrections_buffer.handle_pitch)
    rospy.Subscriber('corrections/roll' , Float64, corrections_buffer.handle_roll)

    # Translation controls
    translate_left_rate_pub     = rospy.Publisher('controls/translate_left_rate',
                                                  Float64, queue_size=1)
    translate_right_rate_pub    = rospy.Publisher('controls/translate_right_rate',
                                                  Float64, queue_size=1)
    translate_up_rate_pub       = rospy.Publisher('controls/translate_up_rate',
                                                  Float64, queue_size=1)
    translate_down_rate_pub     = rospy.Publisher('controls/translate_down_rate',
                                                  Float64, queue_size=1)
    translate_forward_rate_pub  = rospy.Publisher('controls/translate_forward_rate',
                                                  Float64, queue_size=1)
    translate_backward_rate_pub = rospy.Publisher('controls/translate_backward_rate',
                                                  Float64, queue_size=1)

    tf_buffer = tf2_ros.Buffer()
    tf2_ros.TransformListener(tf_buffer)

    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        if not corrections_buffer.is_initialized():
            rate.sleep()
            continue

        try:
            t = tf_buffer.lookup_transform('base_link', 'iss', rospy.Time())
        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException):
            rate.sleep()
            continue

        corrections = corrections_buffer.get_state()

        q = [
            t.transform.rotation.x,
            t.transform.rotation.y,
            t.transform.rotation.z,
            t.transform.rotation.w
        ]

        # Calculate desired actuations in local coordinates
        translation_actuations = qv_mult(q, [
            corrections['x'],
            corrections['y'],
            corrections['z']
        ])

        translate_left_rate_pub    .publish(max(0, -translation_actuations[1]))
        translate_right_rate_pub   .publish(max(0,  translation_actuations[1]))
        translate_up_rate_pub      .publish(max(0,  translation_actuations[2]))
        translate_down_rate_pub    .publish(max(0, -translation_actuations[2]))
        translate_forward_rate_pub .publish(max(0, -translation_actuations[0]))
        translate_backward_rate_pub.publish(max(0,  translation_actuations[0]))

        rate.sleep()
