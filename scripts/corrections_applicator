#!/usr/bin/env python

import rospy
import tf2_ros
import tf_conversions

from std_srvs.srv import Empty
from std_msgs.msg import Float64

import numpy as np
from iss_docking_automation import StateBuffer

# Source: https://answers.ros.org/question/196149/how-to-rotate-vector-by-quaternion-in-python/?answer=196155#post-id-196155
def qv_mult(q1, v1):
    mag = np.linalg.norm(v1)

    v1 = tf_conversions.transformations.unit_vector(v1)
    q2 = list(v1)
    q2.append(0.0)
    return tf_conversions.transformations.quaternion_multiply(
        tf_conversions.transformations.quaternion_multiply(q1, q2),
        tf_conversions.transformations.quaternion_conjugate(q1)
    )[:3] * mag

if __name__ == '__main__':
    rospy.init_node('corrections_applicator')
    corrections_buffer = StateBuffer()

    # Translation corrections
    rospy.Subscriber('corrections/x', Float64, corrections_buffer.handle_x)
    rospy.Subscriber('corrections/y', Float64, corrections_buffer.handle_y)
    rospy.Subscriber('corrections/z', Float64, corrections_buffer.handle_z)

    # Rotation corrections
    rospy.Subscriber('corrections/yaw'  , Float64, corrections_buffer.handle_yaw)
    rospy.Subscriber('corrections/pitch', Float64, corrections_buffer.handle_pitch)
    rospy.Subscriber('corrections/roll' , Float64, corrections_buffer.handle_roll)

    # Translation controls
    x_control_pub = rospy.Publisher('controls/x', Float64, queue_size=1)
    y_control_pub = rospy.Publisher('controls/y', Float64, queue_size=1)
    z_control_pub = rospy.Publisher('controls/z', Float64, queue_size=1)

    # Rotation controls
    yaw_control_pub   = rospy.Publisher('controls/yaw', Float64, queue_size=1)
    pitch_control_pub = rospy.Publisher('controls/pitch', Float64, queue_size=1)
    roll_control_pub  = rospy.Publisher('controls/roll', Float64, queue_size=1)

    tf_buffer = tf2_ros.Buffer()
    tf2_ros.TransformListener(tf_buffer)

    rate = rospy.Rate(20)
    while not rospy.is_shutdown():
        if not corrections_buffer.is_initialized():
            rate.sleep()
            continue

        try:
            t = tf_buffer.lookup_transform('base_link', 'iss', rospy.Time())
        except (tf2_ros.LookupException,
                tf2_ros.ConnectivityException,
                tf2_ros.ExtrapolationException):
            rate.sleep()
            continue

        corrections = corrections_buffer.get_state()

        q = [
            t.transform.rotation.x,
            t.transform.rotation.y,
            t.transform.rotation.z,
            t.transform.rotation.w
        ]

        # Calculate desired translation actuations in local reference
        translation_actuations = qv_mult(q, [
            corrections['x'],
            corrections['y'],
            corrections['z']
        ])

        x_control_pub.publish(translation_actuations[0])
        y_control_pub.publish(translation_actuations[1])
        z_control_pub.publish(translation_actuations[2])

        # Calculate desired rotation actuations in local reference
        rotation_actuations = qv_mult(q, [
            corrections['roll'],
            corrections['pitch'],
            corrections['yaw']
        ])

        roll_control_pub.publish(rotation_actuations[0])
        pitch_control_pub.publish(rotation_actuations[1])
        yaw_control_pub.publish(rotation_actuations[2])

        rate.sleep()
